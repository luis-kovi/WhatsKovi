generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  ADMIN
  SUPERVISOR
  AGENT
}

enum UserStatus {
  ONLINE
  OFFLINE
  AWAY
}

enum TicketStatus {
  PENDING
  OPEN
  CLOSED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum MessageType {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  DOCUMENT
  NOTE
}

enum MessageStatus {
  PENDING
  SENT
  RECEIVED
  READ
}

enum ScheduledMessageRecurrence {
  NONE
  DAILY
  WEEKLY
  MONTHLY
}

enum ScheduledMessageStatus {
  ACTIVE
  PAUSED
  CANCELLED
  COMPLETED
}

enum ScheduledMessageLogStatus {
  SUCCESS
  FAILED
  SKIPPED
}

enum NotificationType {
  NEW_TICKET
  TICKET_MESSAGE
  TICKET_TRANSFER
  REPORT_READY
}

enum NotificationChannel {
  IN_APP
  PUSH
  EMAIL
}

enum ExportFormat {
  PDF
  TXT
  JSON
}

enum ExportStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

enum ReportFileFormat {
  CSV
  XLSX
  PDF
}

enum ReportFrequency {
  DAILY
  WEEKLY
  MONTHLY
}

enum ChatbotTriggerType {
  KEYWORD
  DEFAULT
  MANUAL
}

enum ChatbotSender {
  BOT
  CONTACT
}

enum SurveyStatus {
  PENDING
  SENT
  RESPONDED
  EXPIRED
}

enum SurveyChannel {
  WHATSAPP
  LINK
  MANUAL
}

model User {
  id                String       @id @default(uuid())
  name              String
  email             String       @unique
  password          String
  role              UserRole     @default(AGENT)
  status            UserStatus   @default(OFFLINE)
  avatar            String?
  maxTickets        Int          @default(3)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  
  tickets           Ticket[]
  messages          Message[]
  queues            QueueUser[]
  messageReactions  MessageReaction[]
  quickReplies      QuickReply[]        @relation("UserQuickReplies")
  quickReplyUsages  QuickReplyUsage[]   @relation("UserQuickReplyUsage")
  contactNotes      ContactNote[]       @relation("UserContactNotes")
  contactSegments   ContactSegment[]    @relation("UserContactSegments")
  notifications     Notification[]
  notificationPreference NotificationPreference?
  notificationSubscriptions NotificationSubscription[]
  advancedSettingsUpdates AdvancedSettings[]
  searchHistory     SearchHistory[]
  exportJobs        ExportJob[]
  reportSchedules   ReportSchedule[]
  reportSnapshots   ReportSnapshot[]
  scheduledMessages ScheduledMessage[]
  satisfactionSurveys SatisfactionSurvey[] @relation("SurveyAgent")

  @@map("users")
}

model WhatsAppConnection {
  id                String       @id @default(uuid())
  name              String
  phoneNumber       String?
  status            String       @default("DISCONNECTED")
  qrCode            String?
  isDefault         Boolean      @default(false)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  
  tickets           Ticket[]
  satisfactionSurveys SatisfactionSurvey[]
  
  @@map("whatsapp_connections")
}

model Contact {
  id                String       @id @default(uuid())
  name              String
  phoneNumber       String       @unique
  email             String?
  avatar            String?
  isBlocked         Boolean      @default(false)
  notes             String?
  customFields      Json?
  lastInteractionAt DateTime?    @default(now())
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  
  tickets           Ticket[]
  tags              ContactTag[]
  customFieldValues ContactFieldValue[]
  notesHistory      ContactNote[]
  chatbotSessions   ChatbotSession[]
  satisfactionSurveys SatisfactionSurvey[]
  
  @@map("contacts")
}

model Queue {
  id                String       @id @default(uuid())
  name              String
  color             String       @default("#FF355A")
  description       String?
  greetingMessage   String?
  outOfHoursMessage String?
  priority          Int          @default(0)
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  
  tickets           Ticket[]
  users             QueueUser[]
  quickReplies      QuickReply[]        @relation("QueueQuickReplies")
  quickReplyUsages  QuickReplyUsage[]   @relation("QueueQuickReplyUsage")
  chatbotFlows      ChatbotFlow[]
  satisfactionSurveys SatisfactionSurvey[]
  
  @@map("queues")
}

model QueueUser {
  id                String       @id @default(uuid())
  userId            String
  queueId           String
  
  user              User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  queue             Queue        @relation(fields: [queueId], references: [id], onDelete: Cascade)
  
  @@unique([userId, queueId])
  @@map("queue_users")
}

model Ticket {
  id                String       @id @default(uuid())
  status            TicketStatus @default(PENDING)
  priority          Priority     @default(MEDIUM)
  carPlate          String?
  unreadMessages    Int          @default(0)
  lastMessageAt     DateTime     @default(now())
  closedAt          DateTime?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  
  contactId         String
  contact           Contact      @relation(fields: [contactId], references: [id])
  
  userId            String?
  user              User?        @relation(fields: [userId], references: [id])
  
  queueId           String?
  queue             Queue?       @relation(fields: [queueId], references: [id])
  
  whatsappId        String
  whatsapp          WhatsAppConnection @relation(fields: [whatsappId], references: [id])
  
  messages          Message[]
  tags              TicketTag[]
  quickReplyUsages  QuickReplyUsage[]   @relation("TicketQuickReplyUsage")
  exportJobs        ExportJob[]
  chatbotSessions   ChatbotSession[]
  satisfactionSurvey SatisfactionSurvey?
  scheduledMessages ScheduledMessage[]
  
  @@map("tickets")
}

model SatisfactionSurvey {
  id          String        @id @default(uuid())
  ticketId    String        @unique
  contactId   String
  queueId     String?
  agentId     String?
  whatsappId  String?
  token       String        @unique
  channel     SurveyChannel @default(WHATSAPP)
  status      SurveyStatus  @default(PENDING)
  rating      Int?
  comment     String?
  autoSent    Boolean       @default(true)
  sentAt      DateTime?
  respondedAt DateTime?
  expiresAt   DateTime?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  ticket      Ticket        @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  contact     Contact       @relation(fields: [contactId], references: [id], onDelete: Cascade)
  queue       Queue?        @relation(fields: [queueId], references: [id])
  agent       User?         @relation("SurveyAgent", fields: [agentId], references: [id])
  whatsapp    WhatsAppConnection? @relation(fields: [whatsappId], references: [id])

  @@index([status, sentAt])
  @@index([respondedAt])
  @@index([queueId])
  @@index([agentId])
  @@map("satisfaction_surveys")
}

model Message {
  id                String       @id @default(uuid())
  body              String
  type              MessageType  @default(TEXT)
  status            MessageStatus @default(PENDING)
  mediaUrl          String?
  isPrivate         Boolean      @default(false)
  quotedMsgId       String?
  createdAt         DateTime     @default(now())
  editedAt          DateTime?
  editedBy          String?
  
  ticketId          String
  ticket            Ticket       @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  
  userId            String?
  user              User?        @relation(fields: [userId], references: [id])
  
  quotedMessage     Message?     @relation("MessageQuote", fields: [quotedMsgId], references: [id])
  replies           Message[]    @relation("MessageQuote")
  reactions         MessageReaction[]
  scheduledLogs     ScheduledMessageLog[]
  
  @@map("messages")
}

model MessageReaction {
  id        String   @id @default(uuid())
  emoji     String
  messageId String
  userId    String
  createdAt DateTime @default(now())

  message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([messageId, userId, emoji])
  @@map("message_reactions")
}

model ScheduledMessage {
  id            String                     @id @default(uuid())
  ticketId      String
  userId        String
  body          String
  type          MessageType                @default(TEXT)
  mediaUrl      String?
  isPrivate     Boolean                    @default(false)
  recurrence    ScheduledMessageRecurrence @default(NONE)
  weekdays      String[]                   @default([])
  dayOfMonth    Int?
  timezone      String                     @default("UTC")
  status        ScheduledMessageStatus     @default(ACTIVE)
  scheduledFor  DateTime
  lastRunAt     DateTime?
  nextRunAt     DateTime?
  jobId         String?
  cancelReason  String?
  cancelledAt   DateTime?
  createdAt     DateTime                   @default(now())
  updatedAt     DateTime                   @updatedAt

  ticket        Ticket                     @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user          User                       @relation(fields: [userId], references: [id])
  logs          ScheduledMessageLog[]

  @@index([status])
  @@index([nextRunAt])
  @@map("scheduled_messages")
}

model ScheduledMessageLog {
  id                 String                     @id @default(uuid())
  scheduledMessageId String
  messageId          String?
  status             ScheduledMessageLogStatus   @default(SUCCESS)
  error              String?
  runAt              DateTime                    @default(now())

  scheduledMessage   ScheduledMessage            @relation(fields: [scheduledMessageId], references: [id], onDelete: Cascade)
  message            Message?                    @relation(fields: [messageId], references: [id], onDelete: SetNull)

  @@index([scheduledMessageId, runAt])
  @@map("scheduled_message_logs")
}

model Tag {
  id                String       @id @default(uuid())
  name              String       @unique
  color             String       @default("#FF355A")
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt
  
  tickets           TicketTag[]
  contacts          ContactTag[]
  keywords          TagKeyword[]
  
  @@map("tags")
}

model TicketTag {
  id                String       @id @default(uuid())
  ticketId          String
  tagId             String
  
  ticket            Ticket       @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  tag               Tag          @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@unique([ticketId, tagId])
  @@map("ticket_tags")
}

model ContactTag {
  id                String       @id @default(uuid())
  contactId         String
  tagId             String
  
  contact           Contact      @relation(fields: [contactId], references: [id], onDelete: Cascade)
  tag               Tag          @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@unique([contactId, tagId])
  @@map("contact_tags")
}

enum ContactFieldType {
  TEXT
  NUMBER
  DATE
  BOOLEAN
  SELECT
  MULTI_SELECT
}

model ContactField {
  id          String            @id @default(uuid())
  name        String
  key         String            @unique
  type        ContactFieldType  @default(TEXT)
  description String?
  options     String[]      @default([])
  isRequired  Boolean           @default(false)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  values      ContactFieldValue[]

  @@map("contact_fields")
}

model ContactFieldValue {
  id        String       @id @default(uuid())
  contactId String
  fieldId   String
  value     String
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  contact   Contact      @relation(fields: [contactId], references: [id], onDelete: Cascade)
  field     ContactField @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@unique([contactId, fieldId])
  @@map("contact_field_values")
}

model ContactNote {
  id        String   @id @default(uuid())
  contactId String
  userId    String?
  body      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  contact   Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)
  user      User?    @relation("UserContactNotes", fields: [userId], references: [id], onDelete: SetNull)

  @@index([contactId])
  @@map("contact_notes")
}

model ContactSegment {
  id           String   @id @default(uuid())
  name         String
  description  String?
  filters      Json
  isFavorite   Boolean  @default(false)
  createdById  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  createdBy    User?    @relation("UserContactSegments", fields: [createdById], references: [id], onDelete: SetNull)

  @@map("contact_segments")
}

model QuickReply {
  id                String       @id @default(uuid())
  shortcut          String       @unique
  message           String
  mediaUrl          String?
  isGlobal          Boolean      @default(true)
  usageCount        Int          @default(0)
  lastUsedAt        DateTime?
  ownerId           String?
  queueId           String?
  categoryId        String?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  owner             User?                @relation("UserQuickReplies", fields: [ownerId], references: [id], onDelete: SetNull)
  queue             Queue?               @relation("QueueQuickReplies", fields: [queueId], references: [id], onDelete: SetNull)
  category          QuickReplyCategory?  @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  usages            QuickReplyUsage[]

  @@map("quick_replies")
}

model QuickReplyCategory {
  id          String      @id @default(uuid())
  name        String      @unique
  color       String?     @default("#2563EB")
  displayOrder Int        @default(0)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt

  quickReplies QuickReply[]

  @@map("quick_reply_categories")
}

model QuickReplyUsage {
  id            String   @id @default(uuid())
  quickReplyId  String
  ticketId      String
  userId        String?
  queueId       String?
  createdAt     DateTime @default(now())

  quickReply    QuickReply @relation(fields: [quickReplyId], references: [id], onDelete: Cascade)
  ticket        Ticket     @relation("TicketQuickReplyUsage", fields: [ticketId], references: [id], onDelete: Cascade)
  user          User?      @relation("UserQuickReplyUsage", fields: [userId], references: [id], onDelete: SetNull)
  queue         Queue?     @relation("QueueQuickReplyUsage", fields: [queueId], references: [id], onDelete: SetNull)

  @@index([quickReplyId])
  @@index([ticketId])
  @@index([userId])
  @@map("quick_reply_usage")
}

model Notification {
  id          String               @id @default(uuid())
  userId      String
  type        NotificationType
  title       String
  body        String
  data        Json?
  channels    NotificationChannel[] @default([IN_APP])
  readAt      DateTime?
  createdAt   DateTime             @default(now())
  metadata    Json?

  user        User                 @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("notifications")
}

model NotificationPreference {
  id                   String   @id @default(uuid())
  userId               String   @unique
  notifyNewTicket      Boolean  @default(true)
  notifyTicketMessage  Boolean  @default(true)
  notifyTransfer       Boolean  @default(true)
  pushEnabled          Boolean  @default(false)
  emailEnabled         Boolean  @default(false)
  soundEnabled         Boolean  @default(true)
  soundTheme           String   @default("classic")
  smtpHost             String? 
  smtpPort             Int? 
  smtpUser             String?
  smtpPassword         String?
  smtpFrom             String?
  smtpSecure           Boolean  @default(true)
  quietHoursStart      Int?
  quietHoursEnd        Int?
  muteUntil            DateTime?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}

model NotificationSubscription {
  id        String   @id @default(uuid())
  userId    String
  endpoint  String   @unique
  auth      String
  p256dh    String
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("notification_subscriptions")
}

model AdvancedSettings {
  id                         String   @id @default(uuid())
  companyName                String   @default("WhatsKovi Atendimento")
  brandColor                 String   @default("#FF355A")
  accentColor                String   @default("#7C3AED")
  language                   String   @default("pt-BR")
  supportedLanguages         String[] @default(["pt-BR", "en-US", "es-ES"])
  timezone                   String   @default("America/Sao_Paulo")
  dateFormat                 String   @default("dd/MM/yyyy HH:mm")
  logoUrl                    String?
  logoStorageKey             String?
  inactivityMinutes          Int      @default(15)
  autoCloseHours             Int      @default(12)
  autoCloseMessage           String   @default("Encerramos este atendimento apos um periodo sem respostas. Caso precise de ajuda novamente, estamos por aqui!")
  globalTicketLimit          Int      @default(400)
  perAgentTicketLimit        Int      @default(25)
  soundEnabled               Boolean  @default(true)
  satisfactionSurveyEnabled  Boolean  @default(true)
  notifyNewTicket            Boolean  @default(true)
  notifyTicketMessage        Boolean  @default(true)
  notifyTransfer             Boolean  @default(true)
  pushEnabled                Boolean  @default(false)
  emailEnabled               Boolean  @default(false)
  soundTheme                 String   @default("classic")
  smtpHost                   String?
  smtpPort                   Int?
  smtpUser                   String?
  smtpPassword               String?
  smtpFrom                   String?
  smtpSecure                 Boolean  @default(true)
  updatedById                String?
  createdAt                  DateTime @default(now())
  updatedAt                  DateTime @updatedAt

  updatedBy                  User?    @relation(fields: [updatedById], references: [id], onDelete: SetNull)

  @@map("advanced_settings")
}

model SearchHistory {
  id        String   @id @default(uuid())
  userId    String
  term      String
  filters   Json?
  results   Json?
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@map("search_history")
}

model ExportJob {
  id          String        @id @default(uuid())
  ticketId    String
  userId      String?
  format      ExportFormat
  status      ExportStatus  @default(PENDING)
  filePath    String?
  fileName    String?
  fileSize    Int?
  error       String?
  preview     Json?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  startedAt   DateTime?
  completedAt DateTime?
  expiresAt   DateTime?

  ticket      Ticket        @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user        User?         @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([ticketId])
  @@index([userId])
  @@map("export_jobs")
}

model ReportSchedule {
  id          String           @id @default(uuid())
  userId      String
  name        String
  description String?
  format      ReportFileFormat @default(PDF)
  frequency   ReportFrequency  @default(DAILY)
  timeOfDay   String           @default("08:00")
  weekdays    String[]         @default([])
  dayOfMonth  Int?
  timezone    String           @default("UTC")
  recipients  String[]
  filters     Json
  isActive    Boolean          @default(true)
  jobId       String?
  lastRunAt   DateTime?
  nextRunAt   DateTime?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  snapshots   ReportSnapshot[]

  @@index([userId])
  @@index([isActive, nextRunAt])
  @@map("report_schedules")
}

model ReportSnapshot {
  id          String           @id @default(uuid())
  scheduleId  String?
  userId      String
  format      ReportFileFormat
  filePath    String
  fileName    String
  fileSize    Int?
  filters     Json
  summary     Json
  generatedAt DateTime         @default(now())
  expiresAt   DateTime?

  schedule    ReportSchedule?  @relation(fields: [scheduleId], references: [id], onDelete: SetNull)
  user        User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([scheduleId])
  @@index([userId, generatedAt])
  @@map("report_snapshots")
}

enum AutomationTrigger {
  TICKET_CREATED
  MESSAGE_RECEIVED
  TICKET_STATUS_CHANGED
}

enum AutomationLogStatus {
  SUCCESS
  SKIPPED
  FAILED
}

model AutomationRule {
  id             String            @id @default(uuid())
  name           String
  description    String?
  trigger        AutomationTrigger
  isActive       Boolean           @default(true)
  priority       Int               @default(0)
  stopOnMatch    Boolean           @default(false)
  conditions     Json              @default("[]")
  actions        Json
  metadata       Json?
  testPayload    Json?
  lastExecutedAt DateTime?
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  logs           AutomationLog[]

  @@map("automation_rules")
  @@index([trigger, isActive])
  @@index([priority, updatedAt])
}

model AutomationLog {
  id        String              @id @default(uuid())
  ruleId    String?
  trigger   AutomationTrigger
  status    AutomationLogStatus
  message   String?
  context   Json?
  error     String?
  createdAt DateTime            @default(now())

  rule      AutomationRule?     @relation(fields: [ruleId], references: [id], onDelete: SetNull)

  @@map("automation_logs")
  @@index([trigger, createdAt])
  @@index([createdAt])
}

enum TagMatchType {
  CONTAINS
  EXACT
  STARTS_WITH
}

model TagKeyword {
  id        String       @id @default(uuid())
  tagId     String
  keyword   String
  matchType TagMatchType @default(CONTAINS)
  createdAt DateTime     @default(now())
  updatedAt DateTime     @updatedAt

  tag Tag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@unique([tagId, keyword])
  @@map("tag_keywords")
}

model ChatbotFlow {
  id               String             @id @default(uuid())
  name             String
  description      String?
  isActive         Boolean            @default(false)
  isPrimary        Boolean            @default(false)
  triggerType      ChatbotTriggerType @default(KEYWORD)
  keywords         String[]           @default([])
  entryNodeId      String
  definition       Json
  schedule         Json?
  offlineMessage   String?
  transferQueueId  String?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt

  queue            Queue?             @relation(fields: [transferQueueId], references: [id])
  sessions         ChatbotSession[]

  @@index([isActive])
  @@map("chatbot_flows")
}

model ChatbotSession {
  id             String    @id @default(uuid())
  flowId         String
  ticketId       String
  contactId      String
  currentNodeId  String?
  state          Json?
  completedAt    DateTime?
  transferredAt  DateTime?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  flow           ChatbotFlow   @relation(fields: [flowId], references: [id], onDelete: Cascade)
  ticket         Ticket        @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  contact        Contact       @relation(fields: [contactId], references: [id], onDelete: Cascade)
  interactions   ChatbotInteraction[]

  @@index([flowId])
  @@index([ticketId])
  @@index([contactId])
  @@map("chatbot_sessions")
}

model ChatbotInteraction {
  id         String         @id @default(uuid())
  sessionId  String
  sender     ChatbotSender
  nodeId     String?
  message    String?
  metadata   Json?
  createdAt  DateTime       @default(now())

  session    ChatbotSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@index([sessionId])
  @@map("chatbot_interactions")
}
